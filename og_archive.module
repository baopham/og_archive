<?php

/**
 * @file
 * Allows archiving of groups created by the organic groups module.
 */

/**
 * Implements hook_permission().
 */
function og_archive_permission() {
  return array(
    'administer archiving groups' => array(
      'title' => t('Administer OG Archive Groups'),
    )
  );
}

/**
 * Implements hook_menu().
 */
function og_archive_menu() {
  $items['admin/config/group/archive'] = array(
    'title' => 'OG archive configuration',
    'description' => 'Configure settings for archiving of groups',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_archive_settings'),
    'access arguments' => array('administer archiving groups'),
    'weight' => 10,
    'file' => 'og_archive.admin.inc',
    'file path' => drupal_get_path('module', 'og_archive'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_node_view()
 */
function og_archive_node_view($node, $view_mode, $langcode) {
  if ($view_mode == 'teaser') {
    if (og_archive_isarchived($node->nid)) {
      og_archive_node_action($node, $view_mode);
    }
  }
}

/**
 * Implements hook_node_access()
 */
function og_archive_node_access($node, $op, $account) {
  if (is_object($node) && !og_archive_hide($node->nid)) return NODE_ACCESS_IGNORE;

  switch ($op) {
    case 'view':
      return og_archive_node_action($node, 'full');
    case 'delete':
    case 'update':
      $settings = variable_get('og_archive_settings', array());
      if ($settings['archive_group_nodes'] != 2 && og_is_group_type('node', $node->type))
        return NODE_ACCESS_DENY;
      elseif ($settings['archive_associated_nodes'] != 2 && og_is_group_content_type('node', $node->type))
        return NODE_ACCESS_DENY;
      break;
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_form_alter()
 */
function og_archive_form_alter(&$form, &$form_state, $form_id) {
  if (strrpos($form_id, 'node_form', -1) && (isset($form[OG_AUDIENCE_FIELD]) || isset($form[OG_AUDIENCE_OTHER_GROUPS_FIELD]))) {
    foreach ($form[OG_AUDIENCE_FIELD]['und']['#options'] as $key => $val) {
      // Hide archived groups
      if (is_numeric($key) && og_archive_hide($key))
        unset($form[OG_AUDIENCE_FIELD]['und']['#options'][$key]);
    }
  } elseif ($form_id == 'flag_form' && $form['name']['#default_value'] == 'archive') {
    $form['#submit'][] = '_og_archive_flag_form_submit';
  }
}

/**
 * Update og_archive settings with the new submitted flag's roles
 */
function _og_archive_flag_form_submit($form, &$form_state) {
  $flag = flag_get_flag('archive');
  $settings = variable_get('og_archive_settings', array());
  $settings['roles_archive'] = $flag->roles['flag'];
  variable_set('og_archive_settings', $settings);
}

/**
 * Implements hook_og_membership_insert()
 */
function og_archive_og_membership_insert($membership) {
  if ($membership->entity_type == 'user') {
    $settings = variable_get('og_archive_settings', array());
    if ($settings['archive_edit_users'] == 0 && og_archive_isarchived($membership->gid)) {
      og_membership_delete($membership->id);
      drupal_set_message(t('The group is archived, new users cannot be added'), 'error');
    }
  }
}

/**
 * Implements hook_node_view_alter()
 * Remove subscription link
 */
function og_archive_node_view_alter(&$build) {
  $flag = flag_get_flag('archive');
  if ($build['#view_mode'] == 'full' && $flag->is_flagged($build['#node']->nid)) {
    $settings = variable_get('og_archive_settings', array());
    if ($settings['archive_edit_users'] == 0)
      $build[OG_GROUP_FIELD]['#access'] = FALSE;
  }
}

/**
 * API function to check if a node belongs to an archived group.
 *
 * @param $nid
 *   The node's id
 * @param $uid
 *   The user ID for whom the node archive status is to be checked
 *
 * @return
 *   True if archived, False other wise
 */
function og_archive_isarchived($nid, $uid = '') {
  global $user;
  $uid = ($uid) ? $uid : $user->uid;
  // Super admin has access to all archived nodes.
  if ($uid == 1)
    return FALSE;

  $flag = flag_get_flag("archive");
  if (! $flag || ! $nid)
    return FALSE;

  // Could be a group
  if ($flag->is_flagged($nid)) return TRUE;

  // Could be a group content
  // Get the group(s) it belongs to
  $result = db_select('og_membership', 'om')
    ->fields('om', array('gid'))
    ->condition('entity_type' , 'node', '=')
    ->condition('etid', $nid, '=')
    ->execute();
  foreach ($result as $record) {
    if ($flag->is_flagged($record->gid))
      return TRUE;
  }

  return FALSE;

}

/**
 * Function to check if the group is to be hidden from display
 * after checking settings.
 * @return boolean TRUE if group is to be hidden.
 */
function og_archive_hide($nid) {
  if (og_archive_isarchived($nid) && ! og_archive_unarchive_permission())
    return TRUE;
  return FALSE;
}

/**
 * Function to check if the group is to be hidden from display
 * and content creation is to be allowed
 * after checking settings.
 * @return boolean TRUE if group allow to create.
 */
function og_archive_create_innercontent($nid) {
  $settings = variable_get('og_archive_settings', array());
  if (og_archive_isarchived($nid)) {
    if (!$settings['archive_associated_nodes_creation'] || !og_archive_unarchive_permission())
      return FALSE;
  }
  return TRUE;
}


/**
 * Determine if current user has access to archive and unarchive.
 *
 * @return
 *   True if the user has access, False otherwise
 */
function og_archive_unarchive_permission() {
  global $user;
  if ($user->uid == 1) return TRUE;
  $settings = variable_get('og_archive_settings', array());
  foreach ($settings['roles_archive'] as $k => $v) {
    if (array_key_exists($v, $user->roles))
      return TRUE;
  }
  return FALSE;
}

/**
 * Predifined action for archived og group content.
 * If the view mode is full, deny access if necessary then display drupal message.
 * If the view mode is teaser, hide all content and display the error message in the teaser if necessary. 
 *
 * @param $node
 *   A node object
 * @param $view_mode
 *   Node's view mode: full or teaser
 * 
 * @return
 *   NODE_ACCESS_IGNORE or NODE_ACCESS_DENY
 */
function og_archive_node_action($node, $view_mode) {
  if (og_archive_unarchive_permission()) {
    if ($view_mode == 'full') drupal_set_message(t("This node is archived! and you have permission to archive/unarchive it!"), "error");
    return NODE_ACCESS_IGNORE;
  }
  $settings = variable_get('og_archive_settings', array());
  // Deny access
  if ($settings['archive_group_nodes'] == 0 && og_is_group_type('node', $node->type)) {
    $msg = t("This group is archived! You don't have permission to view it!");
    if ($view_mode == 'full') drupal_set_message($msg, "error");
    else $node->content['body'] = array('#markup' => '<div class="messages error">' . $msg . '</div>');
    return NODE_ACCESS_DENY;
  }
  if ($settings['archive_associated_nodes'] == 0 && og_is_group_content_type('node', $node->type)) {
    $msg = t("The parent group of this node is archived! You don't have permission to archive/unarchive it!");
    if ($view_mode == 'full') drupal_set_message($msg, "error");
    else $node->content['body'] = array('#markup' => '<div class="messages error">' . $msg . '</div>');
    return NODE_ACCESS_DENY;
  }
  if ($settings['archive_group_nodes'] == 1 && og_is_group_type('node', $node->type)) {
    if ($view_mode == 'full') drupal_set_message(t("This group is archived! You have permission to view it!"), "error");
    return NODE_ACCESS_IGNORE;
  }
  if ($settings['archive_associated_nodes'] == 1 && og_is_group_content_type('node', $node->type)) {
    if ($view_mode == 'full') drupal_set_message(t("The group this node belongs to is archived! You have permission to view it!"), "error");
    return NODE_ACCESS_IGNORE;
  }
  return NODE_ACCESS_IGNORE;
}

/*
 * Implements hook_flag().
 */
function og_archive_flag($action, $flag, $content_id, $account) {
  $settings = variable_get('og_archive_settings', array());
  if ($flag->name == 'archive') {
    $archive_list = og_archive_publish_list($content_id);
    $status = ($action == 'flag') ? 'unpublish' : 'publish';
    if ($settings['archive_group_nodes'] == 2)
      og_archive_pub_unpub($status, $content_id);
    if ($settings['archive_associated_nodes'] == 2) {
      foreach ($archive_list as $k => $nid) {
        og_archive_pub_unpub($status, $nid);
      }
    }
  }
}

/*
 * Helper function to retrive list of all nodes to be published/unpublished.
 *
 * @param $gid
 *   The archived group's id
 *
 * @return
 *   Array of all the group contents' entity ids
 */
function og_archive_publish_list($gid) {
  $nodelist = array();
  $result = db_select('og_membership', 'om')
    ->fields('om', array('etid'))
    ->condition('entity_type' , 'node', '=')
    ->condition('gid', $gid, '=')
    ->execute();
  foreach ($result as $record) {
    $nodelist[] = $record->etid;
  }
  return $nodelist;
}

/*
 * Helper function to publish and unpublish nodes.
 *
 * @param $op
 *   A string: 'publish' or 'unpublish'
 * @param $nid
 *   Node's id
 */
function og_archive_pub_unpub($op, $nid) {
  $status = ($op == 'publish') ? 1 : 0;
  $node = node_load($nid);
  $node->status = $status;
  node_save($node);
}
